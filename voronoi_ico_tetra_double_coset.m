close all; clear; clc;

%% Conceptual plot for F_{H\SO(3)/K}, H -> Icosahedral symmetry group, K -> tetrahedral symmetry group

n = 50;
ruby = [255, 0, 0] / 255;

%% Icosahedron group
H = struct ('R', 0, 'n', 0, 'theta', 0);

H(1).R = [-1.0, 0.0, 0.0; 0.0, -1.0, 0.0; 0.0, 0.0, 1.0]; % selbstinvers
H(2).R = [-1.0, 0.0, 0.0; 0.0, 1.0, 0.0; 0.0, 0.0, -1.0]; % selbstinvers
H(3).R = [-0.5, -0.809016994374947, -0.309016994374947; -0.809016994374947, 0.309016994374947, 0.5; -0.309016994374947, 0.5, -0.809016994374947]; % selbstinvers
H(4).R = [-0.5, -0.809016994374947, -0.309016994374947; 0.809016994374947, -0.309016994374947, -0.5; 0.309016994374947, -0.5, 0.809016994374947]; % invers zu 9
H(5).R = [-0.5, -0.809016994374947, 0.309016994374947; -0.809016994374947, 0.309016994374947, -0.5; 0.309016994374947, -0.5, -0.809016994374947]; % selbstinvers
H(6).R = [-0.5, -0.809016994374947, 0.309016994374947; 0.809016994374947, -0.309016994374947, 0.5; -0.309016994374947, 0.5, 0.809016994374947]; % invers zu 7
H(7).R = [-0.5, 0.809016994374947, -0.309016994374947; -0.809016994374947, -0.309016994374947, 0.5; 0.309016994374947, 0.5, 0.809016994374947]; % invers zu 6
H(8).R = [-0.5, 0.809016994374947, -0.309016994374947; 0.809016994374947, 0.309016994374947, -0.5; -0.309016994374947, -0.5, -0.809016994374947]; % selbstinvers
H(9).R = [-0.5, 0.809016994374947, 0.309016994374947; -0.809016994374947, -0.309016994374947, -0.5; -0.309016994374947, -0.5, 0.809016994374947]; % invers zu 4
H(10).R = [-0.5, 0.809016994374947, 0.309016994374947; 0.809016994374947, 0.309016994374947, 0.5; 0.309016994374947, 0.5, -0.809016994374947]; % selbstinvers
H(11).R = [0.0, -1.0, 0.0; 0.0, 0.0, -1.0; 1.0, 0.0, 0.0]; % invers zu 15
H(12).R = [0.0, -1.0, 0.0; 0.0, 0.0, 1.0; -1.0, 0.0, 0.0]; % invers zu 13
H(13).R = [0.0, 0.0, -1.0; -1.0, 0.0, 0.0; 0.0, 1.0, 0.0]; % invers zu 12
H(14).R = [0.0, 0.0, -1.0; 1.0, 0.0, 0.0; 0.0, -1.0, 0.0]; % invers zu 17
H(15).R = [0.0, 0.0, 1.0; -1.0, 0.0, 0.0; 0.0, -1.0, 0.0]; % invers zu 11
H(16).R = [0.0, 0.0, 1.0; 1.0, 0.0, 0.0; 0.0, 1.0, 0.0]; % invers zu 18
H(17).R = [0.0, 1.0, 0.0; 0.0, 0.0, -1.0; -1.0, 0.0, 0.0]; % invers zu 14
H(18).R = [0.0, 1.0, 0.0; 0.0, 0.0, 1.0; 1.0, 0.0, 0.0]; % invers zu 16
H(19).R = [0.5, -0.809016994374947, -0.309016994374947; -0.809016994374947, -0.309016994374947, -0.5; 0.309016994374947, 0.5, -0.809016994374947]; % invers zu 21
H(20).R = [0.5, -0.809016994374947, -0.309016994374947; 0.809016994374947, 0.309016994374947, 0.5; -0.309016994374947, -0.5, 0.809016994374947]; % invers zu 23
H(21).R = [0.5, -0.809016994374947, 0.309016994374947; -0.809016994374947, -0.309016994374947, 0.5; -0.309016994374947, -0.5, -0.809016994374947]; % invers zu 19
H(22).R = [0.5, -0.809016994374947, 0.309016994374947; 0.809016994374947, 0.309016994374947, -0.5; 0.309016994374947, 0.5, 0.809016994374947]; % invers zu 25
H(23).R = [0.5, 0.809016994374947, -0.309016994374947; -0.809016994374947, 0.309016994374947, -0.5; -0.309016994374947, 0.5, 0.809016994374947]; % invers zu 20
H(24).R = [0.5, 0.809016994374947, -0.309016994374947; 0.809016994374947, -0.309016994374947, 0.5; 0.309016994374947, -0.5, -0.809016994374947]; % invers zu 26
H(25).R = [0.5, 0.809016994374947, 0.309016994374947; -0.809016994374947, 0.309016994374947, 0.5; 0.309016994374947, -0.5, 0.809016994374947]; % invers zu 22
H(26).R = [0.5, 0.809016994374947, 0.309016994374947; 0.809016994374947, -0.309016994374947, -0.5; -0.309016994374947, 0.5, -0.809016994374947]; % invers zu 24
H(27).R = [1.0, 0.0, 0.0; 0.0, -1.0, 0.0; 0.0, 0.0, -1.0]; % selbstinvers
H(28).R = [1.0, 0.0, 0.0; 0.0, 1.0, 0.0; 0.0, 0.0, 1.0]; % selbstinvers
H(29).R = [-0.809016994374947, -0.309016994374947, -0.5; -0.309016994374947, -0.5, 0.809016994374947; -0.5, 0.809016994374947, 0.309016994374947]; % selbstinvers
H(30).R = [-0.809016994374947, -0.309016994374947, -0.5; 0.309016994374947, 0.5, -0.809016994374947; 0.5, -0.809016994374947, -0.309016994374947]; % invers zu 35
H(31).R = [-0.809016994374947, -0.309016994374947, 0.5; -0.309016994374947, -0.5, -0.809016994374947; 0.5, -0.809016994374947, 0.309016994374947]; % selbstinvers
H(32).R = [-0.809016994374947, -0.309016994374947, 0.5; 0.309016994374947, 0.5, 0.809016994374947; -0.5, 0.809016994374947, -0.309016994374947]; % invers zu 33
H(33).R = [-0.809016994374947, 0.309016994374947, -0.5; -0.309016994374947, 0.5, 0.809016994374947; 0.5, 0.809016994374947, -0.309016994374947]; % invers zu 32
H(34).R = [-0.809016994374947, 0.309016994374947, -0.5; 0.309016994374947, -0.5, -0.809016994374947; -0.5, -0.809016994374947, 0.309016994374947]; % selbstinvers
H(35).R = [-0.809016994374947, 0.309016994374947, 0.5; -0.309016994374947, 0.5, -0.809016994374947; -0.5, -0.809016994374947, -0.309016994374947]; % invers zu 30
H(36).R = [-0.809016994374947, 0.309016994374947, 0.5; 0.309016994374947, -0.5, 0.809016994374947; 0.5, 0.809016994374947, 0.309016994374947]; % selbstinvers
H(37).R = [-0.309016994374947, -0.5, -0.809016994374947; -0.5, 0.809016994374947, -0.309016994374947; 0.809016994374947, 0.309016994374947, -0.5]; % invers zu 39
H(38).R = [-0.309016994374947, -0.5, -0.809016994374947; 0.5, -0.809016994374947, 0.309016994374947; -0.809016994374947, -0.309016994374947, 0.5]; % invers zu 41
H(39).R = [-0.309016994374947, -0.5, 0.809016994374947; -0.5, 0.809016994374947, 0.309016994374947; -0.809016994374947, -0.309016994374947, -0.5]; % invers zu 37
H(40).R = [-0.309016994374947, -0.5, 0.809016994374947; 0.5, -0.809016994374947, -0.309016994374947; 0.809016994374947, 0.309016994374947, 0.5]; % invers zu 43
H(41).R = [-0.309016994374947, 0.5, -0.809016994374947; -0.5, -0.809016994374947, -0.309016994374947; -0.809016994374947, 0.309016994374947, 0.5]; % invers zu 38
H(42).R = [-0.309016994374947, 0.5, -0.809016994374947; 0.5, 0.809016994374947, 0.309016994374947; 0.809016994374947, -0.309016994374947, -0.5]; % invers zu 44
H(43).R = [-0.309016994374947, 0.5, 0.809016994374947; -0.5, -0.809016994374947, 0.309016994374947; 0.809016994374947, -0.309016994374947, 0.5]; % invers zu 40
H(44).R = [-0.309016994374947, 0.5, 0.809016994374947; 0.5, 0.809016994374947, -0.309016994374947; -0.809016994374947, 0.309016994374947, -0.5]; % invers zu 42
H(45).R = [0.309016994374947, -0.5, -0.809016994374947; -0.5, -0.809016994374947, 0.309016994374947; -0.809016994374947, 0.309016994374947, -0.5]; % selbstinvers
H(46).R = [0.309016994374947, -0.5, -0.809016994374947; 0.5, 0.809016994374947, -0.309016994374947; 0.809016994374947, -0.309016994374947, 0.5]; % invers zu 51
H(47).R = [0.309016994374947, -0.5, 0.809016994374947; -0.5, -0.809016994374947, -0.309016994374947; 0.809016994374947, -0.309016994374947, -0.5]; % selbstinvers
H(48).R = [0.309016994374947, -0.5, 0.809016994374947; 0.5, 0.809016994374947, 0.309016994374947; -0.809016994374947, 0.309016994374947, 0.5]; % invers zu 49
H(49).R = [0.309016994374947, 0.5, -0.809016994374947; -0.5, 0.809016994374947, 0.309016994374947; 0.809016994374947, 0.309016994374947, 0.5]; % invers zu 48
H(50).R = [0.309016994374947, 0.5, -0.809016994374947; 0.5, -0.809016994374947, -0.309016994374947; -0.809016994374947, -0.309016994374947, -0.5]; % selbstinvers
H(51).R = [0.309016994374947, 0.5, 0.809016994374947; -0.5, 0.809016994374947, -0.309016994374947; -0.809016994374947, -0.309016994374947, 0.5]; % invers zu 46
H(52).R = [0.309016994374947, 0.5, 0.809016994374947; 0.5, -0.809016994374947, 0.309016994374947; 0.809016994374947, 0.309016994374947, -0.5]; % selbstinvers
H(53).R = [0.809016994374947, -0.309016994374947, -0.5; -0.309016994374947, 0.5, -0.809016994374947; 0.5, 0.809016994374947, 0.309016994374947]; % invers zu 55
H(54).R = [0.809016994374947, -0.309016994374947, -0.5; 0.309016994374947, -0.5, 0.809016994374947; -0.5, -0.809016994374947, -0.309016994374947]; % invers zu 57
H(55).R = [0.809016994374947, -0.309016994374947, 0.5; -0.309016994374947, 0.5, 0.809016994374947; -0.5, -0.809016994374947, 0.309016994374947]; % invers zu 53
H(56).R = [0.809016994374947, -0.309016994374947, 0.5; 0.309016994374947, -0.5, -0.809016994374947; 0.5, 0.809016994374947, -0.309016994374947]; % invers zu 59
H(57).R = [0.809016994374947, 0.309016994374947, -0.5; -0.309016994374947, -0.5, -0.809016994374947; -0.5, 0.809016994374947, -0.309016994374947]; % invers zu 54
H(58).R = [0.809016994374947, 0.309016994374947, -0.5; 0.309016994374947, 0.5, 0.809016994374947; 0.5, -0.809016994374947, 0.309016994374947]; % invers zu 60
H(59).R = [0.809016994374947, 0.309016994374947, 0.5; -0.309016994374947, -0.5, 0.809016994374947; 0.5, -0.809016994374947, -0.309016994374947]; % invers zu 56
H(60).R = [0.809016994374947, 0.309016994374947, 0.5; 0.309016994374947, 0.5, -0.809016994374947; -0.5, 0.809016994374947, 0.309016994374947]; % invers zu 58

% -------------------------------------------------------------------------

for h_index = 1 : 60
    
    H(h_index).theta = theta (H(h_index).R);
    
    H(h_index).n = log_SO (H(h_index).R);
    
    n_norm = norm (H(h_index).n, 2);
    
    if ( n_norm > 0 )
        
        H(h_index).n = H(h_index).n / n_norm;
        
    else
        
        H(h_index).n = zeros (3, 1);
        
    end
    
    norm_x = norm (H(h_index).theta * H(h_index).n, 2);
    
    if ( abs (norm_x) < 1e-10 )
        
        H(h_index).theta = 0.0;
        
    elseif ( abs (norm_x - 2.0 * pi / 5.0) < 1e-10 )
        
        H(h_index).theta = 2.0 * pi / 5.0;
        
    elseif ( abs (norm_x - 2.0 * pi / 3.0) < 1e-10 )
        
        H(h_index).theta = 2.0 * pi / 3.0;
        
    elseif ( abs (norm_x - 4.0 * pi / 5.0) < 1e-10 )
        
        H(h_index).theta = 4.0 * pi / 5.0;
        
    elseif ( abs (norm_x - pi) < 1e-10 )
        
        H(h_index).theta = pi;
        
    end
    
end

% -------------------------------------------------------------------------

g_x = [0.435897435897436; -0.076923076923077; -0.128205128205128];
g = exp_SO (g_x);

% -------------------------------------------------------------------------

K = struct ('R', 0, 'n', 0, 'theta', 0);

K(1).R = exp_SO (pi * g * [1.0; 0.0; 0.0]);
K(2).R = exp_SO (pi * g * [0.0; 1.0; 0.0]);
K(3).R = exp_SO (pi * g * [0.0; 0.0; -1.0]);

K(4).R = exp_SO ((2.0 * pi / 3.0) * g * [1.0; 1.0; -1.0] / sqrt (3));
K(5).R = exp_SO ((4.0 * pi / 3.0) * g * [1.0; 1.0; -1.0] / sqrt (3));

K(6).R = exp_SO ((2.0 * pi / 3.0) * g * [1.0; -1.0; -1.0] / sqrt (3));
K(7).R = exp_SO ((4.0 * pi / 3.0) * g * [1.0; -1.0; -1.0] / sqrt (3));

K(8).R = exp_SO ((2.0 * pi / 3.0) * g * [-1.0; 1.0; -1.0] / sqrt (3));
K(9).R = exp_SO ((4.0 * pi / 3.0) * g * [-1.0; 1.0; -1.0] / sqrt (3));

K(10).R = exp_SO ((2.0 * pi / 3.0) * g * [-1.0; -1.0; -1.0] / sqrt (3));
K(11).R = exp_SO ((4.0 * pi / 3.0) * g * [-1.0; -1.0; -1.0] / sqrt (3));

K(12).R = eye (3);

%% Tiles

phi = 0.5 * (1.0 + sqrt (5.0));
c = 4.0 * pi / (sqrt (250.0 + 110.0 * sqrt (5.0)) * (sqrt (5.0) - 1.0));

tile = struct ('face_x', 0, 'face_y', 0, 'face_z', 0, 'face_center', 0);

tile(1).face_x = c * [0, 0, 1, phi, 1];
tile(1).face_y = c * [1/phi, -1/phi, -1, 0, 1];
tile(1).face_z = c * [phi, phi, 1, 1/phi, 1];

tile(2).face_x = c * [0, 0, -1, -phi, -1];
tile(2).face_y = c * [1/phi, -1/phi, -1, 0, 1];
tile(2).face_z = c * [phi, phi, 1, 1/phi, 1];

tile(3).face_x = c * [0, -1, -1/phi, 1/phi, 1];
tile(3).face_y = c * [-1/phi, -1, -phi, -phi, -1];
tile(3).face_z = c * [phi, 1, 0, 0, 1];

tile(4).face_x = c * [0, -1, -1/phi, 1/phi, 1];
tile(4).face_y = c * [1/phi, 1, phi, phi, 1];
tile(4).face_z = c * [phi, 1, 0, 0, 1];

tile(5).face_x = c * [1, phi, phi, 1, 1/phi];
tile(5).face_y = c * [-1, 0, 0, -1, -phi];
tile(5).face_z = c * [1, 1/phi, -1/phi, -1, 0];

tile(6).face_x = c * [-1, -phi, -phi, -1, -1/phi];
tile(6).face_y = c * [-1, 0, 0, -1, -phi];
tile(6).face_z = c * [1, 1/phi, -1/phi, -1, 0];

tile(7).face_x = c * [1, phi, phi, 1, 1/phi];
tile(7).face_y = c * [1, 0, 0, 1, phi];
tile(7).face_z = c * [1, 1/phi, -1/phi, -1, 0];

tile(8).face_x = c * [-1, -phi, -phi, -1, -1/phi];
tile(8).face_y = c * [1, 0, 0, 1, phi];
tile(8).face_z = c * [1, 1/phi, -1/phi, -1, 0];

tile(9).face_x = c * [0, 0, 1, phi, 1];
tile(9).face_y = c * [1/phi, -1/phi, -1, 0, 1];
tile(9).face_z = c * [-phi, -phi, -1, -1/phi, -1];

tile(10).face_x = c * [0, 0, -1, -phi, -1];
tile(10).face_y = c * [1/phi, -1/phi, -1, 0, 1];
tile(10).face_z = c * [-phi, -phi, -1, -1/phi, -1];

tile(11).face_x = c * [0, -1, -1/phi, 1/phi, 1];
tile(11).face_y = c * [-1/phi, -1, -phi, -phi, -1];
tile(11).face_z = c * [-phi, -1, 0, 0, -1];

tile(12).face_x = c * [0, -1, -1/phi, 1/phi, 1];
tile(12).face_y = c * [1/phi, 1, phi, phi, 1];
tile(12).face_z = c * [-phi, -1, 0, 0, -1];

%% Plots
figure; hold on;

for face_index = 1 : 12
    
    trisurf ([1, 2, 3, 4, 5], tile(face_index).face_x, tile(face_index).face_y, tile(face_index).face_z, 'FaceAlpha', 0.5, 'Linewidth', 1.3);
    
end

F_x_1 = [];
F_x_2 = [];
F_x_3 = [];

[x_1, x_2, x_3] = meshgrid (linspace (- 1.0, 1.0, n));

for i_1 = 1 : size (x_1, 1)
    for i_2 = 1 : size (x_2, 2)
        for i_3 = 1 : size (x_3, 3)
            
            x = [x_1(i_1, i_2, i_3); x_2(i_1, i_2, i_3); x_3(i_1, i_2, i_3)];
            
            norm_sqrd = x' * x;
            
            if ( norm_sqrd > 1.0 )
                
                continue;
                
            else
                
                R = exp_SO (x);
                
            end
            
            in_F_double_coset = 1;
            
            d1 = d_to_e (R);
            
            for h_index = 1 : 60
                
                d2 = d_to_e (H(h_index).R * R);
                
                if ( d1 >= d2 && h_index ~= 28 )
                    
                    in_F_double_coset = 0;
                    
                    break;
                    
                end
                
                if ( in_F_double_coset )
                    
                    for k_index = 1 : 12
                        
                        d3 = d_to_e (H(h_index).R * R * K(k_index).R);
                        
                        if ( d1 >= d3 && ( h_index ~= 28 || k_index ~= 12 ) )
                            
                            in_F_double_coset = 0;
                            
                            break;
                            
                        end
                        
                    end
                    
                end
                
                if ( in_F_double_coset == 0 )
                    
                    break;
                    
                end
                
            end
            
            if ( in_F_double_coset == 1 )
                
                F_x_1 = [F_x_1; x(1)];
                F_x_2 = [F_x_2; x(2)];
                F_x_3 = [F_x_3; x(3)];
                
                %plot3 (x(1), x(2), x(3), 'r.');
                
            end
            
        end
    end
end

%% Plots
F_hull = convhull (F_x_1, F_x_2, F_x_3);
trisurf (F_hull, F_x_1, F_x_2, F_x_3, 0.49 * pi * (F_x_3 - min (F_x_3)) / (max (F_x_3) - min (F_x_3)) + 0.26 * pi, 'FaceAlpha', 1.0, 'Edgecolor', 'none');

hold off;

light ('Position', 10.0 * [1.0, 0.5, 1.0]);
light ('Position', 3.0 * [0.0, 0.0, 1.0]);
light ('Position', 2.0 * [1.0, 1.0, 0.5]);

%xlabel ('x', 'FontWeight', 'bold');
%ylabel ('y', 'FontWeight', 'bold');
%ZLABEL = zlabel ('z', 'FontWeight', 'bold');

axis (0.25 * pi * [-1.0, 1.0, -1.0, 1.0, -1.0, 1.0]);
axis square;
grid on;
grid minor;
box on;

xticks ([-0.25 * pi, 0.0, 0.25 * pi]);
xticklabels ({'', '0', '$\frac{\pi}{4}$'});

yticks ([-0.25 * pi, 0.0, 0.25 * pi]);
yticklabels ({'$-\frac{\pi}{4}$', '0', '$\frac{\pi}{4}$'});

zticks ([-0.25 * pi, 0.0, 0.25 * pi]);
zticklabels ({'$-\frac{\pi}{4}$', '0', '$\frac{\pi}{4}$'});

ax = gca;
ax.XRuler.MinorTick = 'on';
ax.XRuler.MinorTickValues = 0.125 * pi * [- 1.0, 1.0];
ax.XRuler.MinorTickValuesMode = 'manual';

ax.YRuler.MinorTick = 'on';
ax.YRuler.MinorTickValues = 0.125 * pi * [- 1.0, 1.0];
ax.YRuler.MinorTickValuesMode = 'manual';

ax.ZRuler.MinorTick = 'on';
ax.ZRuler.MinorTickValues = 0.125 * pi * [- 1.0, 1.0];
ax.ZRuler.MinorTickValuesMode = 'manual';

%shading flat;
view (60, 25);

%material ([0.4, 1.0, 1.0]);
%material dull;
%material shiny;
%shading interp;
%lighting phong;

%set (ZLABEL, 'Rotation', eps);
set (gcf, 'color', 'w');

set (gca, 'TickLabelInterpreter', 'latex');
set (gca, 'FontSize', 30);
set (gca, 'Linewidth', 1.2);

map = [summer(200); repmat(ruby, 200, 1)];

colormap (map);
%colorbar;

function theta_val = theta (R)

theta_val = real (acos (0.5 * complex (trace (R) - 1.0)));

end

function d = d_to_e (R)

d = theta (R);

end

function R = exp_SO (x)

R = eye (3);

if ( x(1) ~= 0.0 || x(2) ~= 0.0 || x(3) ~= 0.0 ) % TODO: Can be made even faster with cases? Probably not (it's only the axes)...
    
    x_norm_sqrd = x' * x;
    x_norm = sqrt (x_norm_sqrd);
    
    scale_1 = sin (x_norm) / x_norm; % TODO: Use Taylor expansion for small x_norm?
    
    R(3, 2) = scale_1 * x(1);
    R(1, 3) = scale_1 * x(2);
    R(2, 1) = scale_1 * x(3);
    
    R(2, 3) = - R(3, 2);
    R(3, 1) = - R(1, 3);
    R(1, 2) = - R(2, 1);
    
    x_1_x_2 = x(1) * x(2);
    x_1_x_3 = x(1) * x(3);
    x_2_x_3 = x(2) * x(3);
    
    x_1_sqrd = x(1) * x(1);
    x_2_sqrd = x(2) * x(2);
    x_3_sqrd = x(3) * x(3);
    
    x_1_sqrd_plus_x_2_sqrd = x_1_sqrd + x_2_sqrd;
    x_1_sqrd_plus_x_3_sqrd = x_1_sqrd + x_3_sqrd;
    x_2_sqrd_plus_x_3_sqrd = x_2_sqrd + x_3_sqrd;
    
    X_sqrd = [- x_2_sqrd_plus_x_3_sqrd, x_1_x_2, x_1_x_3; x_1_x_2, - x_1_sqrd_plus_x_3_sqrd, x_2_x_3; x_1_x_3, x_2_x_3, - x_1_sqrd_plus_x_2_sqrd];
    
    scale_2 = (1 - cos (x_norm)) / x_norm_sqrd; % TODO: Use Taylor expansion for small x_norm?
    
    R = R + scale_2 * X_sqrd;
    
end

end

function x = log_SO (R)

theta = acos (0.5 * (trace (R) - 1.0));
%theta = real (acos (0.5 * complex (trace (R) - 1.0)));

x = zeros (3, 1);

if ( abs (theta) < 1e-15 )
    
    return;
    
elseif ( abs (theta - pi) < 1e-7 )
    
    %[V, D] = eig (0.5 * (R - eye (3)))
    %
    %lambda = sqrt (- D(1, 1));
    %
    %Sigma = [0.0, lambda, 0.0; - lambda, 0.0, 0.0; 0.0, 0.0, 0.0];
    %
    %X = V * Sigma * V';
    %x = theta * [X(3, 2); X(1, 3); X(2, 1)]; % TODO: Can be made faster
    
    a = 0.5 * (R(1, 1) - 1.0);
    b = 0.5 * R(2, 1);
    c = 0.5 * R(3, 1);
    d = 0.5 * (R(2, 2) - 1.0);
    e = 0.5 * R(3, 2);
    f = 0.5 * (R(3, 3) - 1.0);
    
    if ( abs (a) < 1e-15 ) % x_1 ~= 0 && x_2 == x_3 == 0
        
        x(1) = theta * sqrt (- d);
        
    elseif ( abs (d) < 1e-15 ) % x_1 == x_3 == 0 && x_2 ~= 0
        
        x(2) = theta * sqrt (- a);
        
    elseif ( abs (f) < 1e-15 ) % x_1 == x_2 == 0 && x_3 ~= 0
        
        x(3) = theta * sqrt (- a);
        
    elseif ( abs (b) < 1e-15 ) % x_1 == 0 || x_2 == 0
        
        if ( abs (c) >= 1e-15 ) % x_1, x_3 ~= 0 && x_2 == 0
            
            x(1) = sqrt (- f);
            x(3) = c / x(1);
            
            x(1) = theta * x(1);
            x(3) = theta * x(3);
            
        else % x_1 == 0 && x_2, x_3 ~= 0
            
            x(2) = sqrt (- f);
            x(3) = e / x(2);
            
            x(2) = theta * x(2);
            x(3) = theta * x(3);
            
        end
        
    elseif ( abs (c) < 1e-15 ) % x_1, x_2 ~= 0 && x_3 == 0
        
        x(1) = sqrt (- d);
        x(2) = b / x(1);
        
        x(1) = theta * x(1);
        x(2) = theta * x(2);
        
    else % x_1, x_2, x_3 ~= 0
        
        x(1) = theta * sign (b) * sign (e) * sqrt (b * c / e);
        x(2) = theta * sign (e) * sqrt (b * e / c);
        x(3) = theta * sqrt (c * e / b);
        
    end
    
else
    
    x = 0.5 * [R(3, 2) - R(2, 3); R(1, 3) - R(3, 1); R(2, 1) - R(1, 2)] * (theta / sin (theta));
    
end

end